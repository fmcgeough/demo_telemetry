# DemoTelemetry

This is a github repo I setup to demonstrate telemetry event generation for the
[Elixir](https://elixir-lang.org/) language's [ecto library](https://hexdocs.pm/ecto/Ecto.html).

Events are generated in Elixir using the [telemetry](https://hexdocs.pm/telemetry/readme.html)
library. As explained in the telemetry doc:

> Telemetry is a lightweight library for dynamic dispatching of events, with a focus on metrics and
> instrumentation. Any Erlang or Elixir library can use telemetry to emit events. Application code and
> other libraries can then hook into those events and run custom handlers.

The sections below provide information that might be helpful when you are first using Ecto telemetry.

## What is Telemetry? What is a Telemetry Event?

Telemetry, as a general concept, has been around quite a while. Early steam
engines performed measurements on a mercury pressure gauge and was able to
indicate the measurement at a short distance.

## Why do I want Telemetry?

Embracing telemetry allows monitoring your software. You can use the
measurements to evaluate and monitor the general health of your software. You
can use it to spot trends that require investigation and evaluation. For
example, it's important to know if APIs provided by your service are suddenly
50% slower. That's something that probably needs immediate investigation! And
it's easily visible if you are using telemetry.

In the context of Ecto, using it's telemetry events can give you:

- how many times is a particular query executed over a time interval?
- what is the current speed of a query?
- what are the trends over time for number of executions and speed of queries?

## How does Telemetry work in Elixir?

Different languages and frameworks provide different telemetry approaches. In
Elixir and Erlang telemetry is generated by the [telemetry
library](https://hex.pm/packages/telemetry). There are still some old Erlang
libraries that do not use this standard approach to generating telemetry. The
library and conventions were not around when the library was first written and
the maintainers have not added support for it. A good example of an Erlang
library that does not use telemetry is the brod library used to interface with
Kafka. However, modern Elixir and Erlang code use telemetry.

In Elixir (and Erlang) code telemetry is generation of a named telemetry event.
The event can include measurements and metadata. There is a standard way for
your app to plug into telemetry events and transmit the metrics to a collection
point.

An event is named using a List of atoms. This must be unique throughout the
system.

Ecto, Phoenix and most likely other libraries have a dependency on the telemetry
library. When your app starts the telemetry library starts a GenServer that
creates an `ets` table. This is used to connect generated events to registered
callbacks for those events. The callback is responsible for doing something with
the generated event - such as sending it on to Datadog or Prometheus.

There are two functions in the telemetry library for registering your interest in events:

- `attach/4` - used to attach to a single event of interest
- `attach_many/4` - used to attach to a list of events of interest

These functions are almost identical. The different is `attach/4` takes a single event name
as its second parameter. The `attach_many/4` takes a list of event names as its second
parameter. The other parameters are exactly the same. Your application should use only
one of these. It makes sense to use `attach_many/4` even if you are currently interested
in only one event. Over time you most likely will want to listen to more.

Here are the parameters to these functions:

- handler_id - this is a unique id. It's defined as a term. This means it can
  be any value - a String, an atom, a Map, etc. Ordinarily, developers use either an atom or
  a String. The important thing to keep in mind is that it must be unique.
- event_name (`attach/4`) or list of event_name (`attach_many/4`) - An event name is a unique
  list of atoms that identify an event. Since this must be unique an event name's list of atoms
  usually starts with the application name. For example, `:ecto` or `:phoenix`. In the case of
  your own service this would be your app name. That can be found in your mix.exs file. The
  atoms that follow make the event unique for the application. You'll want to identify a convention
  used by your app if you are going to generate telemetry events.
- handler_function - This is the function that is called by the telemetry library when an event
  matches the event_name or list of event_name passed in the `attach/4` or `attach_many/4` call.
  There's an example below and some hints on how to write a handler function.
- handler_config - This is your config data. It's defined as a term. This means it can be
  any value that you find useful. Maps are commonly used. But probably the most common thing is
  to pass nil for this value. It's not required and unless you want data passed by the
  telemetry library back to you to handle each event you should just use `nil`.

Once you have attached the handler your handler function will start being called when an event
is generated. The code path for an event is: telemetry event generated -> telemetry library ->
lookup any handlers interested in this event -> telemetry library calls handler function. That is,
this is all happening in the same process ordinarily.

## How and When are Telemetry Events Generated in Ecto?

Ecto is the library that Elixir developers use to interact with a relational database. Different
databases implement behaviour that allows Ecto to interact with different databases without having
all the code inside the ecto library itself. So, for example, there is a
[postgrex](https://hexdocs.pm/postgrex/readme.html) library for Postgresql and a
[myxql](https://hexdocs.pm/myxql/readme.html) library for MySQL.

> Ecto is actually divided into two libraries: ecto and ecto_sql. This is because there are features
> in Ecto that are very useful for apps that do not use a relational database. For example, it is
> common to use Ecto to validate parameters for an API.

There are two telemetry events generated by ecto.

- a Repo initialization event, This occurs when an `Ecto.Repo` starts up (its generated by the
 `Ecto.Repo.Supervisor` module in the ecto library). This event always has the same event name. It
 is `[:ecto, :repo, :init]`.
- a database activity event. This is generated when a database interaction (select, insert, update,
  delete, etc, etc) occurs on a Repo connection. This event does not have a fixed name. It's naming
  is discussed below. This event is generally the only one that developers are interested in. It's
  metrics surrounding the app's interaction with the database. By capturing this data the developer
  can graph what queries are executing the most, which are the slowest queries, and other useful
  information. This is described in the Ecto documentation as an "Adapter Specific Event". This
  somewhat awkward naming is not that important. I'll refer to it in this doc as a "Database
  Activity Event".

## Database Activity Event

As mentioned previously telemetry events are named. The name is given on
generation as the first parameter to `:telemetry.execute/3`. It's pretty clear
what the name is for the event generated in `Ecto.Repo.Supervisor`. It's
hard-coded as `[:ecto, :repo, :init]`.

The other telemetry event (the more useful one) has the name of your repo module
as the event name, by default. This takes your Repo module name and converts it
from camel-case to snake-case. So, if your Ecto repo is called `MyApp.MyRepo` the
event name is `[:my_app, :my_repo]`.

You can set the event name yourself by using a `telemetry_prefix` on your Ecto Repo definition in
your config files. For example, you might set the `telemetry_prefix` to `[:my_app, :ecto,
:primary_db]` for a Repo associated with your primary database and `[:my_app, :ecto, :replica_db]`
for your replica database.

## Plugging Into Ecto Telemetry

The basic mechanics of plugging into Ecto's telemetry events are:

- figure out the event names and put them in a list
- call `:telemetry.attach_many` and give the telemetry system a handler function. The handler is a
  function that takes four parameters:
  - The event name
  - Measurements (Map)
  - Metadata (Map)
  - Handler Config - this is data that you pass into the telemetry library when informing it that
    you want to listen for events. In most cases applications do not use this and nil is passed into
    the telemetry library and it is what is passed to the handler function for this parameter.

## The Database Activity Event

The activity event passes measurements and metadata.

### Measurements

The :measurements map may include the following, all given in the :native time unit:

- :idle_time - the time the connection spent waiting before being checked out for the query
- :queue_time - the time spent waiting to check out a database connection
- :query_time - the time spent executing the query
- :decode_time - the time spent decoding the data received from the database
- :total_time - the sum of (queue_time, query_time, and decode_time)ï¸

### Metadata

- :type - the type of the Ecto query. For example, for Ecto.SQL databases, it would be :ecto_sql_query
- :repo - the Ecto repository (the module name)
- :result - the query result
- :params - the dumped query parameters (formatted for database drivers like Postgrex)
- :cast_params - the casted query parameters (normalized before dumping)
- :query - the query sent to the database as a string
- :source - the source the query was made on (may be nil)
- :stacktrace - the stacktrace information, if enabled, or nil
- :options - extra options given to the repo operation under :telemetry_options

## Demonstrate Ecto Telemetry

- If you setup a repo with a telemetry prefix then the event name generated is
  the prefix you define concatenated with `[:query]`. If you do not define a
  telemetry prefix then Ecto uses the Repo module name (converted to a list of
  atoms) and concatenated with `[:query]` for the event name.
- For example, the example Repo in this project called `DemoTelemetry.Database.OtherRepo`
  generates the event `[:demo_telemetry, :database, :other_repo, :query]`. Note
  how the camel cased module name is converted snake-case.
- To register to receive events you take all the events you are interested in and
  call `:telemetry.attach_many`. You can see an example of this in
  `DemoTelemetry.Metrics.Instrumenter`.
- You have to be careful when you are processing events from the telemetry system.
  If your code raises an exception then your hook into the telemetry system is
  removed and you'll receive no more events.

## Steps

## Create Project

```
mix new --sup demo_telemetry
```

### Edit mix.exs and add dependencies

```
  {:telemetry, "1.3.0"},
  {:ecto_sql, "~> 3.12"},
  {:postgrex, ">= 0.0.0"},
  {:ex_machina, "~> 2.8", only: :test},
  {:faker, "~> 0.18.0", only: :test},
  {:credo, "~> 1.7", only: [:dev, :test], runtime: false},
  {:dialyxir, "~> 1.4", only: [:dev, :test], runtime: false}
```

### Generate a Repo

```
mix ecto.gen.repo -r DemoTelemetry.Database.Repo
mix ecto.gen.repo -r DemoTelemetry.Database.ReaderRepo
mix ecto.gen.repo -r DemoTelemetry.Database.OtherRepo
```

### Edit config.exs

Modify `DemoTelemetry.Database.Repo` and `DemoTelemetry.Database.ReaderRepo`
to set the `telemetry_prefix`. This can be used to override what Ecto uses
by default. The `DemoTelemetry.Database.OtherRepo` Repo module is setup
to use the default. All of these connect to the same database.

```
config :demo_telemetry, DemoTelemetry.Database.Repo,
  database: "demo_telemetry_repo",
  username: "fmcgeough",
  hostname: "localhost",
  telemetry_prefix: [:demo_telemetry, :primary]

config :demo_telemetry, DemoTelemetry.Database.ReaderRepo,
  database: "demo_telemetry_repo",
  username: "fmcgeough",
  hostname: "localhost",
  telemetry_prefix: [:demo_telemetry, :replica]

config :demo_telemetry, DemoTelemetry.Database.OtherRepo,
  database: "demo_telemetry_repo",
  username: "fmcgeough",
  hostname: "localhost"

config :demo_telemetry,
  ecto_repos: [DemoTelemetry.Database.Repo]
```

### Generate a Migration

```
mix ecto.gen.migration add_table
```

Edit the resulting file to add a simple `users` table.

```
defmodule DemoTelemetry.Database.Repo.Migrations.AddTable do
  use Ecto.Migration

  def change do
      create table(:users) do
        add :name, :string, size: 255

        timestamps()
      end
  end
end
```

### Create a Schema module for the users table

```
defmodule DemoTelemetry.Database.Schema.User do
  @moduledoc """
  users table schema
  """
  use Ecto.Schema

  import Ecto.Changeset

  alias __MODULE__

  schema "users" do
    field(:name, :string)

    timestamps()
  end

  def changeset(%User{} = user, params) do
    user
    |> cast(params, [:name])
  end
end
```

### Create an .iex.exs file

```
alias DemoTelemetry.Database.Repo
alias DemoTelemetry.Database.ReaderRepo
alias DemoTelemetry.Database.OtherRepo
alias DemoTelemetry.Database.Schema.User
import Ecto.Query
```

## Simple Tests

This shows the event data (including the event name) received when
interacting with each of the three repos defined in the project.

```
$ iex -S mix
iex> DemoTelemetry.Database.Repo.all(User)
```
![Primary](guides/primary.png)

```
iex> DemoTelemetry.Database.ReaderRepo.all(User)
```
![Replica](guides/replica.png)

```
iex> DemoTelemetry.Database.OtherRepo.all(User)
```
![Other](guides/other.png)

## Transactions and Ecto.Multi

```
iex> alias Ecto.Multi
iex> Multi.new() |> Multi.run(:test, fn _repo, _args -> {:ok, nil} end) |> Repo.transaction()
```

![Multi](guides/multi_commit.png)

```
iex> alias Ecto.Multi
iex> Multi.new() |> Multi.run(:test, fn _repo, _args -> {:error, :badness} end) |> Repo.transaction()
```

![Multi](guides/multi_rollback.png)

## Identify Your Query

When you execute your query you can pass in telemetry_options as a final parameter. This lets
you pass on important information to your metrics handler. It's very important to do so. It
allows you to easily identify what SQL was executed (without attempting to parse the query
passed in the metadata). Note that transaction related operations - begin, commit, rollback - cannot
be named in this way. You will need to explicitly look for those strings in order to identify
them in your metrics.

iex> Repo.all(User, telemetry_options: %{name: "all_users"})

![Query Id](guides/query_id.png)

## Telemetry Event

Another option available is to use `:telemetry_event` when the database operation is done.
Personally I've never used this but it is available. The event generated by ecto_sql uses
the exact name that you pass as the `:telemetry_event` (it doesn't append `[:query]` to the
event name). That means that if you want to receive the event you must include the name
in the list of events you're listening for in call to `:telemetry.attach_many`.

Here's an example using `:telemetry_event`.

```
iex> Repo.all(User, telemetry_event: [:demo_telemetry, :test_telemetry_event])
```

The generated event name will be: `[:demo_telemetry, :test_telemetry_event]`.

![Telemetry Event](guides/telemetry_event.png)
